//////////////////////////////////////////////////////////////////////////////
// Name:        imagebrowser.cpp
// Purpose:     
// Author:      Johnathan Lesbian Seagull
// Modified by: 
// Created:     27/11/2017 15:00:49
// RCS-ID:      
// Copyright:   
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 27/11/2017 15:00:49

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
#include "wx/imaglist.h"
////@end includes

#include "image_file_handler_registry.h"
#include "image_file_handler.h"
#include "imagebrowser.h"
#include "thumbnail_canvas.h"
#include "video_handler.h"
#include "wx/sizer.h"
#include "wx/splitter.h"
#include "wx/dirctrl.h"
#include "wx/textfile.h"
#include "wx/arrstr.h"
#include "wx/filefn.h"
#include "wx/stdpaths.h"
#include "wx/artprov.h"
#include "wx/xml/xml.h"
#include <wx/notebook.h>
#include <wx/clipbrd.h>
#include "directory_functions.h"
#include "imageviewer.h"
#include "image_browserapp.h"
#include "file_name_list.h"
#include "status_bar.h"
#include "mathhelpers.h"
#include <chrono>
#include <thread>
#include <shlobj_core.h>

#include <functional>
#include <iostream>
#include <fstream>
using namespace std;

extern void NoteTime(wxString s);


extern "C"
{
    #include "jpeg_turbo.h"
};


#define STATUS_TEXT_RESIZER(pos, fmt, ...)  { wxString s; s.Printf(fmt, __VA_ARGS__); if(imageBrowserFrame) imageBrowserFrame->StatusMessage(-1, pos, s); else cout << "No imageBrowserFrame" << endl;}


BEGIN_EVENT_TABLE(ImageBrowser, wxPanel)
    EVT_KEY_DOWN(                                          ImageBrowser::OnKeyDown)
    EVT_DIRCTRL_SHOWING_POPUP_MENU( 0,                     ImageBrowser::MenuPopped)
    EVT_TIMER(                      555,                   ImageBrowser::OnDecorationTimer)
    EVT_DIRCTRL_SELECTIONCHANGED(   ID_DIRECTORY_CTRL,     ImageBrowser::OnDirClicked)
    EVT_MENU(                       ID_DELETE_DIRECTORY,   ImageBrowser::OnDeleteDirectory)
    EVT_MENU(                       ID_RESCALE_DIRECTORY,  ImageBrowser::MenuRescaleImages)
    EVT_MENU(                       ID_ARCHIVE_DIRECTORY,  ImageBrowser::OnArchiveDirectory)
    EVT_MENU(                       ID_RANDOM_DIRECTORY,   ImageBrowser::JumpToRandomDirectory)
    EVT_MENU(                       ID_MARK_DIRECTORY,     ImageBrowser::MarkDirectory)
    EVT_MENU(                       ID_BACK_DIRECTORY,     ImageBrowser::BackDirectory)
    EVT_MENU(                       ID_TOUCH_DIRECTORY,    ImageBrowser::TouchDirectory)
END_EVENT_TABLE()

BEGIN_EVENT_TABLE(ImageBrowserFrame, wxPanel)
    EVT_CLOSE(ImageBrowserFrame::EventCloseImageViewer)
END_EVENT_TABLE()

wxRect plusRect;

//BEGIN_EVENT_TABLE(ImageBrowserNotebook, wxAuiNotebook)
//    EVT_NOTEBOOK_PAGE_CHANGED(wxID_ANY, ImageBrowserNotebook::PageChanged)
//    EVT_KEY_DOWN(                       ImageBrowserNotebook::OnKeyDown)
//END_EVENT_TABLE()

ImageBrowserNotebook::ImageBrowserNotebook(ImageBrowserFrame* parent)
 : wxAuiNotebook(parent, wxID_ANY),
   imageBrowserFrame(parent)
{
    customTabArt = new ArtProvider;
    SetArtProvider(customTabArt);

    std::cout << "wxWidgets version: " << wxMAJOR_VERSION << "." << wxMINOR_VERSION << "." << wxRELEASE_NUMBER << std::endl;

    Bind(wxEVT_AUINOTEBOOK_PAGE_CHANGED, &ImageBrowserNotebook::PageChanged,     this);
    Bind(wxEVT_KEY_DOWN,                 &ImageBrowserNotebook::OnKeyDown,       this);
    //Bind(wxEVT_LEFT_UP,                  &ImageBrowserNotebook::OnNotebookClick, this);

    imageResizerPermanent = new ImageResizerPermanent(parent);
    resizerEntries        = imageResizerPermanent->GetResizerEntries();
    imageResizerPermanent->Run();
}

void ImageBrowserNotebook::AddPlusButton()
{
    /*
    wxWindowList& children = GetChildren();
    for (wxWindowList::iterator it = children.begin(); it != children.end(); ++it)
    {
        wxWindow* child = *it;
        if (child->IsKindOf(CLASSINFO(wxAuiTabCtrl)))
        {
            child->Bind(wxEVT_LEFT_UP, &ImageBrowserNotebook::OnNotebookClick, this);
        }
    }
    */
}

ImageBrowserNotebook::~ImageBrowserNotebook()
{
    //cout << "ImageBrowserNotebook::~ImageBrowserNotebook()" << endl;
    //DeleteAllPages();
    //cout << "imageResizerPermanent->Delete()" << endl;
    imageResizerPermanent->Delete();
}


void ImageBrowserNotebook::PageChanged(wxBookCtrlEvent& event)
{
    cout << "ImageBrowserNotebook::PageChanged()" << endl;
    int page = event.GetSelection();
    ImageBrowser* imageBrowser = (ImageBrowser*)GetPage(page);

    cout << "Page changed " << page << endl;
    cout << "Name = " << GetPageText(page) << endl;

    if (GetPageText(page) == "+")
    {
        InsertPage(page, new ImageBrowser(this, this, wxNewId(), (wxXmlNode*)0), "", false);
    }

    wxWindowID tabID = imageBrowser->GetWindowID();

    imageBrowser->SetFocus();
    imageBrowser->Refresh();
    if (imageBrowser->GetThumbnailCanvas())
        imageBrowser->GetThumbnailCanvas()->FullRedraw();
    imageBrowserFrame->PageChanged(tabID);
}

void ImageBrowserNotebook::OnKeyDown(wxKeyEvent& event)
{
    bool  ctrlIsPressed = event.GetModifiers() & wxMOD_CONTROL;
    bool shiftIsPressed = event.GetModifiers() & wxMOD_SHIFT;

    int direction;

    if (shiftIsPressed) direction = -1;
    else                direction =  1;
    
    switch (event.GetKeyCode())
    {
    case WXK_TAB:
        if (ctrlIsPressed)
        {
            int maxPage     = GetPageCount() - 1;
            int currentPage = GetSelection();
            int nextPage    = currentPage + direction;
            nextPage        = clamp(nextPage, 0, maxPage);

            SetSelection(nextPage);
        }
    }
}

void ImageBrowserNotebook::OnNotebookClick(wxMouseEvent& event)
{
    cout << "ImageBrowserNotebook::OnNotebookClick" << endl;
    CallAfter([this, event]()
        {
            wxPoint pt = event.GetPosition();

            if (plusRect.Contains(pt))
            {
                cout << "Add new tab. Before" << endl;
                cout << "Add new tab. After" << endl;
                AddImageBrowser((wxXmlNode*)0);
                cout << "Done. After" << endl;
            }
            else
            {
                //event.Skip(); // Let normal event handling occur
            }
        }
    );
    
}

void ImageBrowserNotebook::AddImageBrowser(wxXmlNode* xmlConfig)
{
    ImageBrowser* imageBrowser = new ImageBrowser(this, this, wxNewId(), xmlConfig);
    //imageBrowsers.push_back(imageBrowser);
    AddPage(imageBrowser, "name");
    SetPathName(imageBrowser->GetCurrentDir(), imageBrowser);

    Layout();
}


void ImageBrowserNotebook::SetPathName(wxFileName pathName, ImageBrowser* imageBrowser)
{
    wxString label;
    const wxArrayString& dirs = pathName.GetDirs();


    if (dirs.size())
    {
        label = dirs.back();
    }
    else
    {
        label = pathName.GetFullPath();
    }

    if (label.size() > 32)
    {
        label = label.Left(32);
    }

    size_t n = GetPageCount(); // imageBrowsers.size();

    for (size_t i = 0; i < n; i++)
    {
        if ((ImageBrowser*)GetPage(i) == imageBrowser)
        {
            SetPageText(i, label);
        }
    }
}

void ImageBrowser::EventOpenImageViewer()
{

}

void ImageBrowserFrame::EventCloseImageViewer(wxCloseEvent& event)
{
    //cout << "ImageBrowserFrame::EventCloseImageViewer()" << endl;

    //Show(false);

    //if (imageViewer)
    //    imageViewer->Show(false);

    Destroy();
}

void ImageBrowser::EventOpenThumbnails()
{

}

void ImageBrowser::EventExit()
{

}

//BEGIN_EVENT_TABLE(wxGenericTreeCtrl, wxControl)
//    EVT_DIRCTRL_SELECTIONCHANGED(ID_DIRECTORY_CTRL, ImageBrowser::OnDirClicked)
//    //EVT_DIRCTRL_MENU_POPPED_UP(wxID_MENU_DIR,       ImageBrowser::DirMenuPopped)
//    EVT_DIRCTRL_SHOWING_POPUP_MENU(0, ImageBrowser::MenuPopped)
//      EVT_KEY_DOWN(ImageBrowser::OnTreeKeyDown)
//    EVT_MENU(ID_DELETE_DIRECTORY, ImageBrowser::OnDeleteDirectory)
//    EVT_MENU(ID_ARCHIVE_DIRECTORY, ImageBrowser::OnArchiveDirectory)
//    EVT_MENU(ID_RANDOM_DIRECTORY, ImageBrowser::JumpToRandomDirectory)
//    EVT_TIMER(555, ImageBrowser::OnDecorationTimer)
//END_EVENT_TABLE()

/*
 * ImageBrowser constructors
 */



ImageBrowser::ImageBrowser(wxWindow* _parent, ImageBrowserNotebook* _imageBrowserNotebook, wxWindowID _id, wxXmlNode* _xmlConfig)
: wxPanel(_parent, -1, wxDefaultPosition, wxDefaultSize, 0 /*wxTAB_TRAVERSAL*/),
  allowTreeDecoration(false),
  decorationTimer(this, 555),
  parent(_parent),
  imageBrowserNotebook(_imageBrowserNotebook),
  recordHistory(true),
  created(false),
  draggingFiles(false),
  id(_id)
{

    //cout << "ImageBrowser::ImageBrowser(" << _parent << ", " << imageBrowserNotebook << ", " << _id << ")" << this << endl;
    history.reserve(32);

    if (!_xmlConfig)
    {
        currentDirectory = "C:\\";
        rescaleX = 3500;
        rescaleY = 3500;
        Init();
        return;
    }

    if (_xmlConfig->GetName() == "Add page")
    {
        cout << "Creating an Add Page tab" << endl;
        Init();
        return;
    }

    for (wxXmlNode* node = _xmlConfig; node; node = node->GetNext())
    {
        if (node->GetName() == "currentDirectory")
        {
            //xmlConfig_Directory = node;
            currentDirectory = node->GetNodeContent();
            //cout << "Current Directory " << currentDirectory  << endl;
        }

        if (node->GetName() == "rescale")
        {
            //xmlConfig_Rescale = node;
            wxString str_rescaleX = node->GetAttribute("x");
            wxString str_rescaleY = node->GetAttribute("y");

            long longInt;
            str_rescaleX.ToLong(&longInt); rescaleX = longInt;
            str_rescaleY.ToLong(&longInt); rescaleY = longInt;

            //cout << "Rescale: x = " << rescaleX  << " y = " << rescaleY << endl;
        }
    }
    Init();
    return;
}



void ImageBrowser::AddXmlConfiguration(wxXmlNode* xmlConfig)
{
    //cout << "ImageBrowser::AddXmlConfiguration()" << endl;
    wxXmlNode* myRoot = new wxXmlNode(wxXML_ELEMENT_NODE, "imageBrowser");

    // Add <currentDirectory> element
    wxXmlNode* currentDirectoryNode = new wxXmlNode(wxXML_ELEMENT_NODE, "currentDirectory");
    currentDirectoryNode->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", currentDirectory));
    myRoot->AddChild(currentDirectoryNode);

    // Add <rescale> element with attributes x and y
    wxXmlNode* rescaleNode = new wxXmlNode(wxXML_ELEMENT_NODE, "rescale");

    wxString scaleX, scaleY;
    scaleX.Printf("%d", rescaleX);
    scaleY.Printf("%d", rescaleX);
    rescaleNode->AddAttribute("x", scaleX);
    rescaleNode->AddAttribute("y", scaleY);

    myRoot->AddChild(rescaleNode);

    xmlConfig->AddChild(myRoot);
}



bool ImageBrowser::Create()
{
    //cout << "ImageBrowser::Create()" << endl;
    srand(time(0));
    CreateControls();
    Centre();

    decorationTimer.StartOnce(1000);
    LoadArrayString(markedDirsIncoming, "marked.txt");

    created = true;

    //cout << "ImageBrowser::Create() done" << endl;
    return true;
}



/*
 * ImageBrowser destructor
 */

ImageBrowser::~ImageBrowser()
{
    if (fileNameList)
    {
        delete fileNameList;
    }
    //cout << "ImageBrowser::~ImageBrowser() " << this << endl;
    //SaveMarkedDirs();
}

/*
 * Member initialisation
 */

bool ImageBrowser::Show(bool show)
{
    //if (!created)
    //{
    //    cout << "  Creating" << endl;
    //    Create(0, -1, _T("Image Browser"), wxPoint(700, 0), wxSize(1200, 640));
    //}

    bool ret = wxWindow::Show(show);

    return ret;
}

void ImageBrowser::Init()
{
    fileNameList = new FileNameList;

    ImageFileHandlerRegistry& imageFileHandlerRegistry = ImageFileHandlerRegistry::instance();
    wxArrayString &filtersList = imageFileHandlerRegistry.GetFiltersList();

    int i, n = filtersList.size();

    for (i = 0; i < n; i++)
    {
        fileNameList->AddFilter(filtersList[i].Lower());
    }

    //cout << "Loading " << currentDirectory << endl;
    fileNameList->LoadFileList(currentDirectory);

    Create();
}


void ImageBrowser::OnDecorationTimer(wxTimerEvent& event)
{
    allowTreeDecoration = true;
}


/*
 * Control creation for ImageBrowser
 */



#define FRAGMENT_TYPE_ALPHA   1
#define FRAGMENT_TYPE_NUMERIC 2

#define IS_A_DIGIT(c)             (wxIsdigit(c))
#define IS_A_DIGIT_OR_POINT(c)    (wxIsdigit(c) || (c=='.'))
#define IS_NUMERIC_PUNCTUATION(c) ((c=='-') || (c=='.'))


int CharType_(wxChar c, wxChar next_c)
{
    if (IS_A_DIGIT(c))
    {
        return FRAGMENT_TYPE_NUMERIC;
    }
    else
    {
        if (IS_NUMERIC_PUNCTUATION(c))
        {
            if (IS_A_DIGIT(next_c) || (next_c==0))
            {
                return FRAGMENT_TYPE_NUMERIC;
            }
        }
        return FRAGMENT_TYPE_ALPHA;
    }
} 
 
wxChar GetNextChar(wxString &s)
{
	if (s.Length() > 0)
		return s[0];
	else
		return 0;
}

wxChar GetNextChar2_(wxString &s, int i)
{
	if (s.Length() > i)
		return s[i];
	else
		return 0;
}

wxString GetFragment_(wxString &s, int &fragmentType)
{
    int charsRemaining = s.Length();

    int numCharsAbsorbed = 0;
    wxChar c, next_c;
    
	int i = 2;
    wxString fragment;

    if (s.Length() >= 1)
    {
        c = s[0];
    }
    else
    {
        fragmentType = FRAGMENT_TYPE_ALPHA;
        return wxString("");
    }

    if (s.Length() > 1)
    {
        next_c = s[1];
    }
    else
    {
        next_c = 0;
    }

    fragmentType = CharType_(c, next_c);
    
    if (fragmentType == FRAGMENT_TYPE_ALPHA)
    {
        do
        {
            fragment += c;
            c         = next_c;
			next_c    = GetNextChar2_(s, i++);
            charsRemaining--;

        } while ((CharType_(c, next_c) == FRAGMENT_TYPE_ALPHA) && (charsRemaining));
    }
    else if (fragmentType == FRAGMENT_TYPE_NUMERIC)
    {
        do
        {
            fragment += c;
            c = next_c;
            next_c = GetNextChar2_(s, i++);
            charsRemaining--;

        } while ((CharType_(c, next_c) == FRAGMENT_TYPE_NUMERIC) && (charsRemaining));
    }

    s.Remove(0, i-2);
    return fragment;
}

int CompareStringsNatural_(const wxString &_a, const wxString &_b)
{
	wxString a(_a);
	wxString b(_b);

	while (1)
	{
		int fragTypeA, fragTypeB;
		wxString fragA = GetFragment_(a, fragTypeA);
		wxString fragB = GetFragment_(b, fragTypeB);

		int lenA = fragA.Length();
		int lenB = fragB.Length();

		if ((lenA == 0) && (lenB == 0))			return  0;
		if ((lenA == 0) && (lenB  > 0))			return -1;
		if ((lenA  > 0) && (lenB == 0))			return  1;
 
		if ((fragTypeA == FRAGMENT_TYPE_NUMERIC) &&
			(fragTypeB == FRAGMENT_TYPE_NUMERIC))
		{
			double av, bv;
			fragA.ToDouble(&av);
			fragB.ToDouble(&bv);

			if (av == bv)
			{
				continue;
			}

			if (av < bv)
			{
				return -1;
			}
			else
			{
				return 1;
			}
		}

		if ((fragTypeA == FRAGMENT_TYPE_ALPHA) &&
			(fragTypeB == FRAGMENT_TYPE_ALPHA))
		{
			int c = fragA.Cmp(fragB);

			if (c == 0)
			{
				continue;
			}

			//if (c < 0)
			//{
			//}
			//else
			//{
			//}

			return c;
		}

		if ((fragTypeA == FRAGMENT_TYPE_ALPHA) &&
			(fragTypeB == FRAGMENT_TYPE_NUMERIC))
		{
			return 1;
		}
		else
		{
			return -1;
		}
	}

	return 0;
}


void ImageBrowser::ReNumberImages(wxCommandEvent &evt)
{
    if (dirTreeCtrl)
    {
        wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
        wxDirItemData* data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));
    }

}

void ImageBrowser::MakeTopDirectory(wxCommandEvent& evt)
{
    if (dirTreeCtrl)
    {
        wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
        wxDirItemData* data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));
    }
    //cout << "Make Top " << data->m_path << endl;
}


// This needs to pass the request up to the ImageBrowserNotebook
void ImageBrowser::MenuRescaleImages(wxCommandEvent& event)
{
    if (!dirTreeCtrl)
        return;

    FileNameList    fileNameList;
    wxDirItemData  *data;
    wxArrayString   selectedFileNames;
    wxString        pathToRescale;
    wxTreeItemId    id = dirTreeCtrl->GetPopupMenuItem();

    if (!id)
    {
        pathToRescale = currentDirectory;
    }
    else
    {
        data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));
        pathToRescale = data->m_path;
    }

    fileNameList.AddFilter(wxT("*.jpg"));           // We only rescale JPEGs
    fileNameList.AddFilter(wxT("*.jpeg"));
    fileNameList.FillArrayWithFileNamesFrom(pathToRescale, selectedFileNames);

    if (thumbnailCanvas)
        thumbnailCanvas->StopLoadingThumbnails(pathToRescale);

    //int rescaleX = GetConfigParser()->GetIntWithDefault("rescaleX", 3000);
    //int rescaleY = GetConfigParser()->GetIntWithDefault("rescaleY", 3000);


    ChooseRescaleSize custom(rescaleX, rescaleY);

    deque_thread_safe<ResizerEntry>* resizerEntries = imageBrowserNotebook->GetResizerEntries();

    if (custom.ShowModal() == wxID_OK)
    { 
        int maxWidth  = custom.GetWidth();
        int maxHeight = custom.GetHeight();

        //GetConfigParser()->SetInt("rescaleX", maxWidth);            // Save the settings
        //GetConfigParser()->SetInt("rescaleY", maxHeight);
        //GetConfigParser()->Write();

        int n = selectedFileNames.size();

        for (int i = 0; i < n; i++)
        {
            wxFileName fullPath = selectedFileNames[i];
            resizerEntries->emplace_back(fullPath, maxWidth, maxHeight);
        }
    }
    else
    {
        //cout << "Hit Cancel" << endl;
    }
    this->SetFocus();
}

/*
void ImageBrowser::MenuRescaleImages(wxCommandEvent &event)
{
    wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
    wxDirItemData *data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));

    thumbnailCanvas->StopLoadingThumbnails(data->m_path);


    int rescaleX = GetConfigParser()->GetIntWithDefault("rescaleX", 3000);
    int rescaleY = GetConfigParser()->GetIntWithDefault("rescaleY", 3000);
    ImageResizer* imageResizer = new ImageResizer(data->m_path, rescaleX, rescaleY);

    //ChooseRescaleSize *custom = new ->Run();
    }
    else
    {
        //cout << "Hit Cancel" << endl;
    }
}
*/

void ImageBrowser::MenuCopyPath(wxCommandEvent& evt)
{
    if (!dirTreeCtrl)
        return;

    wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
    wxDirItemData* data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));

    if (wxTheClipboard->Open())
    {
        // This data objects are held by the clipboard,
        // so do not delete them in the app.
        wxTheClipboard->SetData(new wxTextDataObject(data->m_path));
        wxTheClipboard->Close();
    }
}

void ImageBrowser::MenuOpenDirectory(wxCommandEvent &evt)
{
    if (!dirTreeCtrl)
        return;

    wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
    wxDirItemData *data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));

    wxString command = wxT("explorer \"") + data->m_path + wxT("\"");

    wxExecute(command.c_str(), wxEXEC_ASYNC, NULL);
    //cout << "Make Top " << data->m_path << endl;
}

/*
void ImageBrowser::DirMenuPopped(wxCommandEvent &event)
{
	cout << "DirMenuPopped" << endl;

	dirTreeCtrl->GetMenu()->AppendSeparator();
	int id = dirTreeCtrl->NewMenuItem("Renumber Images");
	dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::ReNumberImages, this, id);
}
*/

void ImageBrowser::MenuPopped(wxCommandEvent &event)
{
    if (!dirTreeCtrl)
        return;

    wxMenu *menu = dirTreeCtrl->GetPopupMenu();
	menu->AppendSeparator();


    //wxWindowID id = wxNewId();

    wxWindowID id = wxNewId();
    menu->Append(id, "Renumber Images");
    dirTreeCtrl->Bind(wxEVT_MENU,       &ImageBrowser::ReNumberImages, this, id);

    id = wxNewId();
    menu->Append(id, "Delete Directory");
    dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::MenuDeleteDirectory, this, id);

    //id = wxNewId();
    //menu->Append(id, "Make Top Directory");
    ////cout << "ID: " << id << endl;
    //dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::MakeTopDirectory, this, id);

    id = wxNewId();
    menu->Append(id, "Rescale Images");
    //cout << "ID: " << id << endl;
    dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::MenuRescaleImages, this, id);

    id = wxNewId();
    menu->Append(id, "Open Directory");
    //cout << "ID: " << id << endl;
    dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::MenuOpenDirectory, this, id);

    id = wxNewId();
    menu->Append(id, "Copy Path");
    //cout << "ID: " << id << endl;
    dirTreeCtrl->Bind(wxEVT_MENU, &ImageBrowser::MenuCopyPath, this, id);

    menu->UpdateUI();
}


//typedef std::function< void(int) > classFuncPtr;

void ImageBrowser::SetAcceleratorTable(const wxAcceleratorTable &accel)
{
    wxWindow::SetAcceleratorTable(accel);
    if (thumbnailCanvas)
        thumbnailCanvas->SetAcceleratorTable(accel);
}


//wxStaticText          *debuggingWindow = 0;
wxTextCtrl* debuggingWindow = 0;
wxString debuggingText = "Debugging Text:\n";

void SetDebuggingText(wxString text)
{
    debuggingText = text;
    debuggingText.Append("\n");

    if (debuggingWindow)
    {
        debuggingWindow->Clear();
        debuggingWindow->SetValue(debuggingText);
    }
}

void AppendDebuggingText(wxString text)
{
    debuggingText.Append(text);
    debuggingText.Append("\n");

    if (debuggingWindow)
    {
        debuggingWindow->SetValue(debuggingText);
    }
}

#include "Iris_01.xpm"

/*
void ImageBrowser::OnDragFiles(wxMouseEvent& event)
{
    //cout << "OnDragFiles()" << endl;

    //if (draggingFiles)
    {
        cout << "Tree Drag " << event.GetPosition().x << endl;
        wxTreeCtrl* treeCtrl = dirTreeCtrl->GetTreeCtrl();
        wxTreeItemId itemId = treeCtrl->HitTest(event.GetPosition());

        if (prevDragItemId.IsOk())
        {
            if (prevDragItemId != itemId)
            {
                treeCtrl->SetItemDropHighlight(prevDragItemId, false);
            }
        }
        treeCtrl->SetItemDropHighlight(itemId, true);
        prevDragItemId = itemId;
    }
}


wxDragResult ImageBrowser::OnDragOver(wxCoord x, wxCoord y, wxDragResult defResult)
{
    cout << "ImageBrowser::OnDragOver()" << endl;

}
*/

void ImageBrowser::OnDropDirFiles(wxDropFilesEvent& event)
{
    if (!dirTreeCtrl)
        return;

    //cout << "OnDropDirFiles()" << endl;
    draggingFiles = false;

    int n = event.GetNumberOfFiles();
    wxString* s = event.GetFiles();
    //cout << "ImageBrowser::OnDropDirFiles(" << ")" << endl;
    //cout << event.GetPosition().x << ", " << event.GetPosition().y << endl;

    wxTreeCtrl *treeCtrl = dirTreeCtrl->GetTreeCtrl();

    wxPoint point = event.GetPosition();
    wxTreeItemId treeItemId = treeCtrl->HitTest(point);


    //cout << "treeItemId = " << treeItemId << endl;

    if (treeItemId)
    {
        treeCtrl->SetItemDropHighlight(treeItemId, false);
        wxDirItemData* data = (wxDirItemData*)(treeCtrl->GetItemData(treeItemId));

        for (int i = 0; i < n; i++)
        {
            //cout << "  " << s[i] << endl;

            wxFileName fileName = s[i];
            wxFileName destination = data->m_path + fileName.GetFullName();

            if (fileName.GetVolume() == destination.GetVolume())
            {
                cout << "  move " << fileName.GetFullPath() << " to " << destination.GetFullPath() << endl;
                wxCopyFile(fileName.GetFullPath(), destination.GetFullPath());
                wxRemoveFile(fileName.GetFullPath());
            }
            else
            {
                cout << "  copy " << fileName.GetFullPath() << " to " << destination.GetFullPath() << endl;
                wxCopyFile(fileName.GetFullPath(), destination.GetFullPath());
            }
        }
    }
}

void NoticeClick(wxTreeEvent& event)
{
    wxLogMessage("Selection changed event fired!");
    //cout << "Selection changed event fired!" << endl;
    event.Skip(); // Allow propagation if needed

}

void ImageBrowserFrame::AddNewTab(wxCommandEvent&)
{
    imageBrowserNotebook->AddImageBrowser();
}


ImageBrowserFrame::ImageBrowserFrame(Image_BrowserApp* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style)
: image_BrowserApp(parent),
  configChangesBlocked(false)
{
    //cout << "ImageBrowserFrame::ImageBrowserFrame(" << parent << ")" << endl;
    wxFrame::Create(NULL, id, caption, pos, size, style);

    ImageBrowserFrame* itemFrame1 = this;
    itemFrame1->SetIcon(wxIcon(voo_icon));

    statusBarThreadSafe = new StatusBarThreadSafe(this);

    //Bind(wxEVT_DIRCTRL_SELECTIONCHANGED, NoticeClick);
    wxBoxSizer* frameSizer = new wxBoxSizer(wxVERTICAL);

    cout << "new ImageBrowserNotebook" << endl;
    imageBrowserNotebook   = new ImageBrowserNotebook(this);
    cout << "done new ImageBrowserNotebook" << endl;

    //imageBrowserNotebook->GetArtProvider()->SetActiveColour(wxColour(128, 128, 255));

    //auiArtProvider.SetActiveColour(wxColour(128, 128, 255));
    
    //auiArtProvider.SetActiveColour(wxColour(128, 128, 255));

    frameSizer->Add(imageBrowserNotebook, wxSizerFlags(1).Expand());
    SetSizer(frameSizer);

    ReadConfiguration();
    imageBrowserNotebook->AddPlusButton();

    //wxXmlNode newPageNodeConfig(wxXML_TEXT_NODE, "New page");
    //imageBrowserNotebook->AddPage(new ImageBrowser(imageBrowserNotebook, imageBrowserNotebook, -1, &newPageNodeConfig), "+", false);
    //imageBrowserNotebook->Bind(wxEVT_AUINOTEBOOK_PAGE_CHANGED, &ImageBrowserNotebook::PageChanged, this);

    statusBarThreadSafe->Run();
    ImageBrowser* firstImageBrowser = imageBrowserNotebook->GetImageBrowser(0);
    wxWindowID tabID = firstImageBrowser->GetWindowID();

    PageChanged(tabID);
    firstImageBrowser->SetFocus();
    imageBrowserNotebook->GetArtProvider()->SetActiveColour(wxColour(128, 128, 255));
    imageBrowserNotebook->GetArtProvider()->SetColour(wxColour(128, 255, 128));
    //imageBrowserNotebook->GetArtProvider()->SetNormalFont
}

ImageBrowserFrame::~ImageBrowserFrame()
{
    //cout << "ImageBrowserFrame::~ImageBrowserFrame() " << this << endl;
    //imageBrowserNotebook->DeleteAllPages();
    statusBarThreadSafe->Delete();
}

void ImageBrowserFrame::PageChanged(wxWindowID tabID)
{
    statusBarThreadSafe->SwitchToTab(tabID);
}


void ImageBrowserFrame::RegisterXmlConfigChange()
{
    if (configChangesBlocked)
    {
        //cout << "BLOCKED" << endl;
        return;
    }

    wxXmlDocument xmlConfig;
    wxXmlNode* vooRoot = new wxXmlNode(wxXML_ELEMENT_NODE, "voo");

    xmlConfig.SetRoot(vooRoot);

    size_t n = imageBrowserNotebook->GetPageCount();

    for (size_t i = 0; i < n; i++)
    {
        ImageBrowser *imageBrowser = (ImageBrowser*)imageBrowserNotebook->GetPage(i);
        imageBrowser->AddXmlConfiguration(vooRoot);
    }

    //std::vector<ImageBrowser*>& imageBrowsers = imageBrowserNotebook->GetImageBrowsers();
    //
    //cout << "Looping through image browsers" << endl;
    //for (auto& imageBrowser : imageBrowsers)
    //{
    //    cout << imageBrowser << endl;
    //    imageBrowser->AddXmlConfiguration(vooRoot);
    //}

    xmlConfig.Save("config.xml");
}


void ImageBrowserFrame::ReadConfiguration()
{
    wxXmlDocument            doc;
    wxFileName fileName("config.xml");

    configChangesBlocked = true;

    //cout << "Exists " << fileName.Exists() << endl;

    if (!doc.Load("config.xml"))
    {
        wxLogError("Failed to load XML file.");
        return;
    }

    wxXmlNode* root = doc.GetRoot();
    if (root->GetName() != "voo")
    {
        wxLogError("Unexpected root node.");
        return;
    }

    // Iterate through the <imageBrowser> nodes
    for (wxXmlNode* node = root->GetChildren(); node; node = node->GetNext())
    {
        if (node->GetName() == "imageBrowser")
        {
            //cout << "Found Image Browser" << endl;
            wxXmlNode* xmlConfig = node->GetChildren();
            imageBrowserNotebook->AddImageBrowser(xmlConfig);
            continue;
        }

        if (node->GetName() == "videoPlayer")
        {
            VideoHandler::SetVideoPlayer(node->GetContent());
        }
    }

    configChangesBlocked = false;
}



void ImageBrowserNotebook::RegisterXmlConfigChange() const
{
    imageBrowserFrame->RegisterXmlConfigChange();
}

void ImageBrowserNotebook::StatusMessage(wxWindowID tabID, size_t place, wxString text)
{
    if (imageBrowserFrame)
        imageBrowserFrame->StatusMessage(tabID, place, text);
    else
        cout << "imageBrowserFrame is null" << endl;
}

/*
void ImageBrowser::CreateControls()
{
    static int numPages = 0;
    wxBoxSizer* splitter1 = new wxBoxSizer(wxHORIZONTAL);
 
    wxStaticText* text;

    if (numPages++)
    {
        text = new wxStaticText(this, wxID_ANY, "ImageBrowser 1");
        cout << "Making Page 0" << endl;
    }
    else
    {
        text = new wxStaticText(this, wxID_ANY, "ImageBrowser 0");
        cout << "Making Page 1" << endl;
    }

    splitter1->Add(text, wxEXPAND);
    SetSizer(splitter1);
}
*/


/*
void ImageBrowser::CreateControls()
{
    static int numPages = 0;
    wxBoxSizer* boxSizer = new wxBoxSizer(wxHORIZONTAL);

    wxStaticText* text;

    if (numPages++)
    {
        text = new wxStaticText(this, wxID_ANY, "ImageBrowser 1");
        cout << "Making Page 0" << endl;
    }
    else
    {
        text = new wxStaticText(this, wxID_ANY, "ImageBrowser 0");
        cout << "Making Page 1" << endl;
    }

    boxSizer->Add(text, wxEXPAND);
    SetSizer(boxSizer);
}

*/

void ImageBrowser::CreateControls()
{    
    //cout << "ImageBrowser::CreateControls()" << endl;
    if (0)
    {
        wxFrame* debuggingFrame = new wxFrame(this, -1, wxT("Debugging"), wxPoint(200, 600), wxSize(400, 400));
        wxBoxSizer* debugSizer = new wxBoxSizer(wxHORIZONTAL);
        debuggingFrame->SetSizer(debugSizer);
        debuggingWindow = new wxTextCtrl(debuggingFrame, -1, "Default text", wxDefaultPosition, wxDefaultSize, wxTE_READONLY | wxTE_MULTILINE);
        debugSizer->Add(debuggingWindow, 1, wxEXPAND);
        debuggingFrame->Show(true);
    }

    ImageFileHandlerRegistry& imageFileHandlerRegistry = ImageFileHandlerRegistry::instance();

    // Image Viewer
    // ------------
    imageViewer = new ImageViewer(this, -1, wxT("Image Viewer"), wxDefaultPosition, wxDefaultSize, 0);
    imageViewer->AddViewableExtensions(imageFileHandlerRegistry.GetViewableExtensions());

    // Splitter Window
    // ---------------
    splitter1 = new wxSplitterWindow(this, -1, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL);
    splitter1->SetSize(GetClientSize());
    splitter1->SetSashGravity(1.0);

    // Directory Tree
    // --------------
    
    dirTreeCtrl = new wxGenericDirCtrl(splitter1, ID_DIRECTORY_CTRL, _T("C:\\"), wxDefaultPosition, wxSize(800, 600),  wxDIRCTRL_DIR_ONLY             |
                                                                                                                       wxDIRCTRL_EDIT_LABELS          |
                                                                                                                       wxDIRCTRL_POPUP_MENU           |
                                                                                                                       wxDIRCTRL_POPUP_MENU_SORT_NAME |
                                                                                                                       wxDIRCTRL_POPUP_MENU_SORT_DATE );
    
    if (dirTreeCtrl)
    {
        treeCtrl = dirTreeCtrl->GetTreeCtrl();
        wxTreeItemId computerId = treeCtrl->GetRootItem();

        treeCtrl->Bind(wxEVT_TREE_ITEM_EXPANDED, &ImageBrowser::TreeExpanded, this, -1);
        treeCtrl->Bind(wxEVT_DROP_FILES, &ImageBrowser::OnDropDirFiles, this, -1);
        treeCtrl->DragAcceptFiles(true);
    }
    //treeCtrl->Bind(wxEVT_MOTION,     &ImageBrowser::OnDragFiles,    this, -1);

    treeDropTargetHandler = new TreeDropTargetHandler;
    treeCtrl->SetDropTarget(treeDropTargetHandler);
    treeDropTargetHandler->SetTreeCtrl(treeCtrl);

    // Thumbnail Canvas
    // ----------------
    thumbnailCanvas = new ThumbnailCanvas(splitter1, *fileNameList, this, ID_SCROLLEDWINDOW, wxDefaultPosition, wxDefaultSize);
    thumbnailCanvas->SetImageViewer(imageViewer);
    imageViewer->SetThumbnailCanvas(thumbnailCanvas);
    thumbnailCanvas->SetScrollbars(10, 10, 50, 275);
    thumbnailCanvas->LoadThumbnails(".");

    //splitter1->SplitVertically(dirTreeCtrl, new wxPanel(splitter1), 300);
    //splitter1->SplitVertically(new wxPanel(splitter1), thumbnailCanvas, 300);
    //splitter1->SplitVertically(new wxPanel(splitter1), new wxPanel(splitter1), 300);
    splitter1->SplitVertically(dirTreeCtrl, thumbnailCanvas, 300);
    splitter1->SetSashGravity(0.0);


    wxBoxSizer* pageSizer = new wxBoxSizer(wxVERTICAL);
    pageSizer->Add(splitter1, 1, wxEXPAND);
    SetSizer(pageSizer);
    
    LoadPrivateDirs();

    if (dirTreeCtrl)
        dirTreeCtrl->ExpandPath(currentDirectory);

    wxAcceleratorEntry entries[7];
    entries[0].Set(wxACCEL_CTRL, (int) 'D', ID_DELETE_DIRECTORY);
    entries[1].Set(wxACCEL_CTRL, (int) 'S', ID_RESCALE_DIRECTORY);
    entries[2].Set(wxACCEL_CTRL, (int) 'K', ID_ARCHIVE_DIRECTORY);
    entries[3].Set(wxACCEL_CTRL, (int) 'R', ID_RANDOM_DIRECTORY);
    entries[4].Set(wxACCEL_CTRL, (int) 'M', ID_MARK_DIRECTORY);
    entries[5].Set(wxACCEL_CTRL, (int) 'T', ID_TOUCH_DIRECTORY);
    entries[6].Set(wxACCEL_CTRL, (int) 'B', ID_BACK_DIRECTORY);
    wxAcceleratorTable accel(7, entries);
    SetAcceleratorTable(accel);

    SetDebuggingText("Hello");
    Layout();
    //cout << "ImageBrowser::CreateControls() done" << endl;
}

bool ImageBrowser::ShowToolTips()
{
    return true;
}

void ImageBrowser::ShowImageViewer(wxString fileName)
{
    //cout << "ImageBrowser::ShowImageViewer(" << fileName << ")" << endl;
    //cout << "file number = " << fileNameList->GetFileNumber(fileName) << endl;
    //cout << (*fileNameList)[fileNameList->GetFileNumber(fileName)] << endl;

    //cout << "imageViewer = " << imageViewer << endl;
    imageViewer->DisplayImage(fileName);
}

/*
 * Get bitmap resources
 */

wxBitmap ImageBrowser::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin ImageBrowser bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end ImageBrowser bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon ImageBrowser::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin ImageBrowser icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end ImageBrowser icon retrieval
}

void ImageBrowser::RefreshDirTree(wxString path)
{
    if (!dirTreeCtrl)
        return;

    dirTreeCtrl->CollapsePath(path);
    dirTreeCtrl->ExpandPath(path);
}

void ImageBrowser::DirectoryWasDeleted(wxString path, wxTreeItemId removedId)
{
    //cout << "ImageBrowser::DirectoryWasDeleted(" << path << endl;

    dirTreeCtrl->SelectPath(path);
    
    wxTreeItemId siblingId = treeCtrl->GetNextSibling(removedId);   // siblingId is the nearest node to the one being deleted.
                                                                    // Either the next ...
    if (!siblingId.IsOk())                                          // 
    {                                                               // 
        siblingId = treeCtrl->GetPrevSibling(removedId);            // or the previous ...
                                                                    // 
        if (!siblingId.IsOk())                                      // 
        {                                                           // 
            siblingId = treeCtrl->GetItemParent(removedId);         // or the parent.
        }                                                           // 
    }                                                               // 

    if (currentDirectory.Contains(path))                            // If we're deleting the currently selected path,
    {                                                               // 
        treeCtrl->SelectItem(siblingId);                            // then we need to jump to the sibling path
        treeCtrl->Delete(removedId);                                // before we delete it.
        treeCtrl->EnsureVisible(siblingId);                         // 
        wxDirItemData *siblingData = (wxDirItemData*)treeCtrl->GetItemData(siblingId);
        currentDirectory = siblingData->m_path;                     // 
    }                                                               // 
    else                                                            // otherwise
    {                                                               // 
        treeCtrl->Delete(removedId);                                // just delete it. No problems.
    }                                                               // 

    if (thumbnailCanvas)
    {
        thumbnailCanvas->DirectoryWasDeleted(path);
        thumbnailCanvas->HideImageViewer();
    }
    treeCtrl->SetFocus();
}


void ImageBrowser::OnDirClicked(wxTreeEvent& event)
{
    std::this_thread::sleep_for(std::chrono::milliseconds(50));

    if (dirTreeCtrl)
	{
        if (recordHistory && thumbnailCanvas && thumbnailCanvas->GetNumThumbnails())
        {
            history.Add(currentDirectory);
            for (auto hist : history)
            {
                //cout << "History: " << hist << endl;
            }
        }
        else
        {
            recordHistory = true;
        }
        
        wxTreeItemId id = event.GetItem();
        currentDirectory = dirTreeCtrl->GetPath(id);

        wxFileName filePath(currentDirectory);
        imageBrowserNotebook->SetPathName(filePath, this);

        //xmlConfig_Directory->SetContent(currentDirectory);
        imageBrowserNotebook->RegisterXmlConfigChange();

        dirTreeCtrl->GetTreeCtrl()->SetScrollPos(wxHORIZONTAL, 0, true);

        if (thumbnailCanvas)
        {
            thumbnailCanvas->LoadThumbnails(currentDirectory);
            thumbnailCanvas->Refresh();
        }
        //imageBrowserFrame->GetConfigParser()->SetString("currentDirectory", currentDirectory.ToStdString());
        //imageBrowserFrame->GetConfigParser()->Write();
	}

	event.Skip();
}


void ImageBrowser::TreeExpanded(wxTreeEvent &event)
{
    wxTreeItemId id = event.GetItem();
    wxDirItemData *data = (wxDirItemData*)(treeCtrl->GetItemData(id));
    
    if (allowTreeDecoration)
    {
        GreyEmptyDirectories(*treeCtrl, id, knownDirList);
    }
}

void ImageBrowser::SelectPathOnly(wxString path)
{
    //cout << "SelectPathOnly(" << path << ")" << endl;
    //
    //wxArrayString selectedPaths;
    //
    //dirTreeCtrl->GetPaths(selectedPaths);
    //
    //int i, n = selectedPaths.size();
    //bool needToSelectPath = true;
    //
    //for (i = 0; i < n; i++)
    //{
    //    cout << "  " << selectedPaths[i] << endl;
    //    if (selectedPaths[i] != path)
    //    {
    //        cout << "    deselecting " << endl;
    //        dirTreeCtrl->SelectPath(selectedPaths[i], false);
    //    }
    //    else
    //    {
    //        cout << "    nope" << endl;
    //        needToSelectPath = false;
    //    }
    //}
    //
    //if (needToSelectPath)
    //{
    //    cout << "  selecting " << path << endl;
    //    dirTreeCtrl->SelectPath(path, true);
    //}

    dirTreeCtrl->UnselectAll();
    //dirTreeCtrl->SelectPath(path, true);
    dirTreeCtrl->ExpandPath(path);
}


void ImageBrowser::BackDirectory(wxCommandEvent& event)
{
    if (history.size())
    {
        wxString path = history.back();
        history.pop_back();
        recordHistory = false;
        dirTreeCtrl->ExpandPath(path);
    }
}

void ImageBrowser::MarkDirectory(wxCommandEvent& event)
{
    //cout << "Marking: " << currentDirectory << endl;

    markedDirsOutgoing.push_back(currentDirectory);
    //SaveArrayString(markedDirsOutgoing, "marked.txt");
    SaveMarkedDirs();
}


// Save the incoming and outgoing arrays to a file, with no duplicates
void ImageBrowser::SaveMarkedDirs()
{
    return;

    // Save Outgoing
    int i, n = markedDirsIncoming.size();
    wxTextFile out("marked.txt");
    
    if (n == 0)
    {
        cout << "No marked directories to save" << endl;
        if (out.Exists())
        {
            wxRemoveFile("marked.txt");
        }
        return;
    }
    

    if (!out.Exists())
    {
        bool success = out.Create();
        if (!success)
        {
            return;
        }
    }
    out.Open();
    out.Clear();


    for (i=0; i<n; i++)
    {
        //cout << "  Out: " << markedDirsIncoming[i] << endl;
        out.AddLine(markedDirsIncoming[i]);
    }

    // Save Incoming (but checking for duplicates)
    n = markedDirsOutgoing.size();
    for (i = 0; i < n; i++)
    {
        //cout << "  In:  " << markedDirsOutgoing[i] << endl;
        wxString path = markedDirsOutgoing[i];
        if (markedDirsIncoming.Index(path) == wxNOT_FOUND)      // duplicate check
        {
            out.AddLine(path);
        }
    }

    out.Write();
    out.Close();
}

void ImageBrowser::JumpToRandomDirectory(wxCommandEvent &event)
{
    static const int HAS_FILES = 1;
    static const int HAS_DIRS  = 2;

    if ((rand() & 0x0F) == 0x00)
    {
        if (markedDirsIncoming.size())
        {
            wxString path = markedDirsIncoming.front();
            //cout << "Using Marked directory " << path << endl;
            markedDirsIncoming.RemoveAt(0, 1);
            dirTreeCtrl->ExpandPath(path);

            treeCtrl->SetFocus();                   // Set focus away from thumbnailCanvas and back
            if (thumbnailCanvas)
                thumbnailCanvas->SetFocus();            // to ensure TNC get a focus event.
            SaveMarkedDirs();
            return;
        }
    }
    int n = knownDirList.size();


    if (!n)
        return;

    int r = rand() % n;

    //cout << "Using Random directory " << r << " / " << n << endl;
    //if (!n)
    //    return;

    wxFileName fn(knownDirList[r]);
    wxString sub;
    bool success;

    for (int i = 0; i < 10; i++)
    {
        wxDir path(fn.GetFullPath());

        int contents = (path.HasFiles()*HAS_FILES) | (path.HasSubDirs()*HAS_DIRS);
        
        switch (contents)
        {
        case HAS_FILES:
            dirTreeCtrl->ExpandPath(fn.GetFullPath());
            treeCtrl->SetFocus();
            if (thumbnailCanvas)
                thumbnailCanvas->SetFocus();
            return;

        case HAS_DIRS:
            success = path.GetFirst(&sub);
            if (success)
            {
                fn.AppendDir(sub);
            }
            break;

        case HAS_FILES + HAS_DIRS:
            dirTreeCtrl->ExpandPath(fn.GetFullPath());
            treeCtrl->SetFocus();
            if (thumbnailCanvas)
                thumbnailCanvas->SetFocus();
            return;

        default:
            r = rand() % n;
            fn = knownDirList[r];
            break;
        }
    }

    dirTreeCtrl->ExpandPath(fn.GetFullPath());
    treeCtrl->SetFocus();
    if (thumbnailCanvas)
        thumbnailCanvas->SetFocus();
}

void ImageBrowser::TouchDirectory(wxCommandEvent& event)
{
    wxFileName currentDirectory = GetCurrentDir();
    currentDirectory.Touch();
}

void ImageBrowser::OnTreeKeyDown(wxKeyEvent& event)
{
    //cout << "Tree Key Down" << endl;
}

void ImageBrowser::OnKeyDown(wxKeyEvent &event)
{
    switch (event.GetKeyCode())
    {
        case '1':
            //cout << "BACKSPACE" << endl;
            wxString path = history.back();
            history.pop_back();
            recordHistory = false;
            dirTreeCtrl->ExpandPath(path);
            break;
    }
    //cout << "ImageBrowser::OnKeyDown(" << event.GetKeyCode() << ")" << endl;
}


void ImageBrowser::LoadPrivateDirs()
{
}

wxString ImageBrowser::GetCurrentDir()
{
    return currentDirectory;
}


void Pause(int timeMs)
{
    wxStopWatch sw;

    sw.Start();
    while (sw.Time() < timeMs)
    {
    }
}

wxString tabs = "";

bool RemoveDirectory(wxString pathName)
{
    wxString fn;
    wxDir dir(pathName);
    wxArrayString paths;
    int attemptsRemaining = 0;
    int i = -2;

    if (!dir.IsOpened())
    {
        return false;
    }

    bool cont = dir.GetFirst(&fn);

    // if there are files to process
    if (cont)
    {
        do {
            wxString subPath = dir.GetName() + wxFILE_SEP_PATH + fn;
            paths.Add(subPath);
        }
        while (dir.GetNext(&fn));

        attemptsRemaining = paths.size() * 2;

        do {
            if (i < 0)
            {
                if (i == -2)
                    Pause(100);
                else
                    Pause(10);
                i = paths.size() - 1;
            }

            wxString subPath = paths[i--];

            // if the next filename is actually a directory
            if (wxDirExists(subPath + wxFILE_SEP_PATH))
            {
                // delete this directory
                tabs += "    ";
                bool success = RemoveDirectory(subPath + wxFILE_SEP_PATH);

                if (success)
                {
                    paths.Remove(subPath);
                }
            }
            else
            {
                // otherwise attempt to delete this file
                if (!wxRemoveFile(subPath))
                { // failed
                    cout << tabs << "failed to delete file: " << subPath << endl;
                }
                else
                { // success
                    paths.Remove(subPath);
                }
            }
        } while ((attemptsRemaining--) && (paths.size()>0));
    }

    bool success = wxRmDir(pathName);

    tabs = tabs.Left(tabs.Length() - 4);
    return true;
}


void ImageBrowser::OnDeleteDirectory(wxCommandEvent &event)
{
    wxFileName parentPath  = currentDirectory;
    parentPath.RemoveLastDir();

    wxString pathToDelete = currentDirectory;

    if (thumbnailCanvas)
    {
        thumbnailCanvas->StopLoadingThumbnails(pathToDelete);
        thumbnailCanvas->UnLoadThumbnails(pathToDelete);
    }

    bool success = DeleteDirectory(pathToDelete);

    if (success)
    {
        dirTreeCtrl->SelectPath(pathToDelete);
        wxTreeItemId id = dirTreeCtrl->GetTreeCtrl()->GetSelection();
        DirectoryWasDeleted(pathToDelete, id);
    }
}


// Called when user Right-clicks, and chooses "Delete Directory"
// 
void ImageBrowser::MenuDeleteDirectory(wxCommandEvent &evt)
{
    wxTreeItemId id = dirTreeCtrl->GetPopupMenuItem();
    wxDirItemData *data = (wxDirItemData*)(dirTreeCtrl->GetTreeCtrl()->GetItemData(id));

    wxString path = data->m_path;
    if (thumbnailCanvas)
        thumbnailCanvas->UnLoadThumbnails(path);
    bool success = DeleteDirectory(path);

    if (success)
    {
        DirectoryWasDeleted(path, id);
    }
}



void ImageBrowser::OnArchiveDirectory(wxCommandEvent &event)
{

}


void ImageBrowser::LoadArrayString(wxArrayString &arrayString, wxString fileName)
{
    wxTextFile in(fileName);

    if (!in.Exists())
        return;

    in.Open();

    int i, n = in.GetLineCount();

    for (i = 0; i < n; i++)
    {
        wxString path = in.GetLine(i);
        arrayString.push_back(path);
    }
    in.Close();
}


void ImageBrowser::SaveArrayString(wxArrayString &arrayString, wxString fileName)
{
    wxTextFile out(fileName);

    out.Open();
    out.Clear();

    int i, n = arrayString.size();

    for (i=0; i<n; i++)
    {
        out.AddLine(arrayString[i]);
    }
    out.Write();
    out.Close();
}


// Pop up a dialog, asking the user to confirm delete
// If YES, then call ImageBrowser::RemoveDirectory(path)
// 
bool ImageBrowser::DeleteDirectory(wxString path)
{
    wxMessageDialog *test = new wxMessageDialog(nullptr, wxT("Delete ") + path, wxT("Warning"), wxYES_NO | wxNO_DEFAULT);
    int ret = test->ShowModal();

    if (ret == wxID_YES)
    {
        RemoveDirectory(path);
        return true;
    }
    else
    {
        return false;
    }
}

void ImageBrowser::FullRedrawThumbnails()
{
    
}

//ConfigParser* ImageBrowser::GetConfigParser()
//{
//    return imageBrowserFrame->GetConfigParser();
//}

void ImageBrowser::ReportDirectoryInfo(wxString path, wxTreeItemId id, int flags)
{
}

void LoadImage2(wxImage &image, wxString fileName)
{
    image.SetOption(wxIMAGE_OPTION_GIF_TRANSPARENCY, wxIMAGE_OPTION_GIF_TRANSPARENCY_UNCHANGED);
    wxFileName fn(fileName);
    wxString   extension = fn.GetExt().Upper();
    jpeg_load_state jpegLoadState;

    if ((extension == "JPG") ||
        (extension == "JPEG"))
    {
        int success = ReadJpegHeader(&jpegLoadState, (const  char*)fileName.c_str());
        jpeg_load_state *load_state = &jpegLoadState;

        int w = load_state->width, h = load_state->height;

        if (success)
        {
            image.Create(w, h);
            image.SetRGB(wxRect(0, 0, w, h), 128, 64, 0);
            JpegRead(image.GetData(), load_state);
        }
    }
    else if (extension == "PNG")
    {
        image.LoadFile(fileName);
    }
}

void ImageResizerPermanent::SaveState()
{
    wxTextFile out("rescaling.txt");

    if (!out.Exists())
        out.Create();

    out.Open();
    out.Clear();

    int i, n = resizerEntries.size();

    for (i=0; i<n; i++)
    {
        wxString record;
        record.Printf("%s\n%d\n%d", resizerEntries[i].fileName.GetFullPath(),
                                    resizerEntries[i].xSize,
                                    resizerEntries[i].ySize);
       out.AddLine(record);
    }

    bool success = out.Write();
    out.Close();
}

void ImageResizerPermanent::LoadState()
{
    wxTextFile in("rescaling.txt");

    if (!in.Exists())
        return;

    in.Open();

    int i, n = in.GetLineCount();

    for (i = 0; i < n; i+=3)
    {
        wxString fileName, xSizeString, ySizeString;
        long     xSize, ySize;

        fileName    = in.GetLine(i + 0);
        xSizeString = in.GetLine(i + 1);
        ySizeString = in.GetLine(i + 2);

        bool xSuccess = xSizeString.ToLong(&xSize);
        bool ySuccess = ySizeString.ToLong(&ySize);

        if (!xSuccess || !ySuccess)
            break;

        resizerEntries.emplace_back(fileName, xSize, ySize);
    }
    in.Close();
}

wxThread::ExitCode ImageResizerPermanent::Entry()
{
    const int X_OVERSIZE = 1;
    const int Y_OVERSIZE = 2;
    const int RESCALED   = 4;

    SetPriority(wxPRIORITY_MIN);
    LoadState();

    while (1)
    {
        //cout << "Loop" << endl;

        if (TestDestroy())
        {
            //cout << "Returning" << endl;
            return 0;
        }
        else
        {
            //cout << "Not Destroy" << endl;
        }

        if (resizerEntries.IsEmpty())
        {
            //cout << "resizerEntries.IsEmpty()" << endl;
            continue;
        }

        ResizerEntry resizerEntry = resizerEntries.pop_front();

        wxFileName   fullPath         = resizerEntry.fileName.GetFullPath();
        wxString     fileNameFragment = fullPath.GetName().Left(10) + "..." + fullPath.GetExt();
        int          maxWidth         = resizerEntry.xSize;
        int          maxHeight        = resizerEntry.ySize;
        int          imagesRemaining  = resizerEntries.size();
        wxImage      image;

        STATUS_TEXT_RESIZER(STATUS_BAR_INFORMATION, "Loading %s %d remain", fileNameFragment, imagesRemaining);

        LoadImage2(image, fullPath.GetFullPath());

        if (!image.IsOk())
        {
            continue;
        }

        float imageWidth  = image.GetSize().GetWidth();
        float imageHeight = image.GetSize().GetHeight();
        int   newWidth    = image.GetSize().GetWidth();
        int   newHeight   = image.GetSize().GetHeight();

        float ratioX = imageWidth  / (float)maxWidth;
        float ratioY = imageHeight / (float)maxHeight;

        int   flags = 0;

        if (ratioX > 1.0)   flags |= X_OVERSIZE;
        if (ratioY > 1.0)   flags |= Y_OVERSIZE;


        switch (flags)
        {
        default:
        case 0:
            break;

        case X_OVERSIZE:
            flags |= RESCALED;
            newWidth  = int(imageWidth / ratioX + 0.5);
            newHeight = int(imageHeight / ratioX + 0.5);
            break;

        case Y_OVERSIZE:
            flags |= RESCALED;
            newWidth  = int(imageWidth / ratioY + 0.5);
            newHeight = int(imageHeight / ratioY + 0.5);
            break;

        case X_OVERSIZE | Y_OVERSIZE:
            flags |= RESCALED;
            if (ratioX > ratioY)
            {
                newWidth  = int(imageWidth / ratioX + 0.5);
                newHeight = int(imageHeight / ratioX + 0.5);
            }
            else
            {
                newWidth  = int(imageWidth / ratioY + 0.5);
                newHeight = int(imageHeight / ratioY + 0.5);
            }
            break;
        }

        if (flags & RESCALED)
        {
            STATUS_TEXT_RESIZER(STATUS_BAR_INFORMATION, "Rescaling %s %d remain", fileNameFragment, imagesRemaining);
            image.Rescale(newWidth, newHeight, wxIMAGE_QUALITY_BILINEAR);
        }

        STATUS_TEXT_RESIZER(STATUS_BAR_INFORMATION, "Saving %s %d remain", fileNameFragment, imagesRemaining);

        JpegWrite(fullPath.GetFullPath(), newWidth, newHeight, image.GetData(), 80);

        image.Destroy();

        SaveState();                // Save our current state to a file, so that we can resume after a crash.
    }

    STATUS_TEXT_RESIZER(STATUS_BAR_INFORMATION, "  ");
    return 0;
}


int ChooseRescaleSize::GetWidth()
{
    long width;
    widthCtrl->GetValue().ToLong(&width);
    return width;
}

int ChooseRescaleSize::GetHeight()
{
    long height;
    heightCtrl->GetValue().ToLong(&height);
    return height;
}

ChooseRescaleSize::ChooseRescaleSize(int xs, int ys)
: wxDialog(NULL, wxID_ANY, wxT("Select maximum size"), wxDefaultPosition, wxSize(250, 230))
{
    wxBoxSizer* vbox  = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* hbox1 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* hbox2 = new wxBoxSizer(wxHORIZONTAL);


    wxString widthString;
    wxString heightString;

     widthString.Printf("%d", xs);
    heightString.Printf("%d", ys);

    wxStaticText *labelWidth  = new wxStaticText(this, -1, ("Max Width: "),  wxPoint( 15, 30), wxSize(100, 12));
    wxStaticText *labelHeight = new wxStaticText(this, -1, ("Max Height: "), wxPoint( 15, 30), wxSize(100, 12));
    widthCtrl   = new   wxTextCtrl(this, -1, widthString,  wxPoint(100, 30), wxSize(100, 12));
    heightCtrl  = new   wxTextCtrl(this, -1, heightString, wxPoint(100, 30), wxSize(100, 12));

    hbox1->Add(labelWidth,  1, wxEXPAND);
    hbox1->Add(widthCtrl,   1, wxEXPAND);
    hbox2->Add(labelHeight, 1, wxEXPAND);
    hbox2->Add(heightCtrl,  1, wxEXPAND);

    vbox->Add(hbox1, 1, wxEXPAND);
    vbox->Add(hbox2, 1, wxEXPAND);
    vbox->Add(CreateButtonSizer(wxOK | wxCANCEL), 1, wxEXPAND);

    SetSizer(vbox);

    Centre();
}



/*
bool TreeDropTargetHandler::OnDrop(wxCoord x, wxCoord y)
{
    //cout << "TreeDropTargetHandler::OnDrop()" << endl;
    if (!treeCtrl)
        return false;

    if (prevDragItemId.IsOk())
    {
        //cout << "Clearing" << endl;
        treeCtrl->SetItemDropHighlight(prevDragItemId, false);
        prevDragItemId.Unset();
    }

    return true;
}

wxDragResult TreeDropTargetHandler::OnDragOver(wxCoord x, wxCoord y, wxDragResult defResult)
{
    //cout << "Tree Drag " << event.GetPosition().x << endl;
    //wxTreeCtrl* treeCtrl = dirTreeCtrl->GetTreeCtrl();

    if (!treeCtrl)
        return defResult;

    wxTreeItemId itemId = treeCtrl->HitTest(wxPoint(x, y));

    if (prevDragItemId.IsOk())
    {
        if (prevDragItemId != itemId)
        {
            treeCtrl->SetItemDropHighlight(prevDragItemId, false);
        }
    }
    treeCtrl->SetItemDropHighlight(itemId, true);
    prevDragItemId = itemId;
   
    //cout << "TreeDropTargetHandler::OnDragOver(" << x << ", " << y << ")" << endl;
    return wxDragNone;
}
*/


