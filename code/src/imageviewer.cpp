/////////////////////////////////////////////////////////////////////////////
// Name:        imageviewer.cpp
// Purpose:     
// Author:      Johnathan Lesbian Seagull
// Modified by: 
// Created:     05/01/2018 22:27:05
// RCS-ID:      
// Copyright:   
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 05/01/2018 22:27:05

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include <wx/app.h>
#include "image_browserapp.h"
#include "imageviewer.h"
#include "file_name_list.h"
#include "status_bar.h"
#include <iostream>

wxDECLARE_APP(Image_BrowserApp);

using namespace std;

////@begin XPM images

////@end XPM images


/*
 * ImageViewer type definition
 */

IMPLEMENT_CLASS( ImageViewer, wxFrame )
BEGIN_EVENT_TABLE( ImageViewer, wxFrame )
    EVT_KEY_DOWN(ImageViewer::OnKeyDown)
    EVT_KEY_UP(  ImageViewer::OnKeyUp)
    //EVT_IDLE(ImageViewer::OnIdle)
    EVT_TIMER(IMAGE_VIEWER_TIMER_ID, ImageViewer::OnTimer)
    EVT_MOUSEWHEEL(ImageViewer::OnMouseWheel)
    EVT_CLOSE(ImageViewer::OnClose)
END_EVENT_TABLE()


/*
 * ImageViewer constructors
 */

ImageViewer::ImageViewer()
    : glPanel(0),
    fileNameList(0),
    currentImage(0),
    displayNumber(-1),
    closeEnabled(false)
{
    Init();
}

ImageViewer::ImageViewer( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style)
    : glPanel(),
    fileNameList(0),
    currentImage(0),
    displayNumber(-1)
{
    Init();
    Create( parent, id, caption, pos, size, style );
}


/*
 * ImageViewer creator
 */

bool ImageViewer::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin ImageViewer creation
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    Centre();
////@end ImageViewer creation
    return true;
}


/*
 * ImageViewer destructor
 */

ImageViewer::~ImageViewer()
{
////@begin ImageViewer destruction
////@end ImageViewer destruction
}


/*
 * Member initialisation
 */

void ImageViewer::Init()
{
////@begin ImageViewer member initialisation
    keys.resize(512, 0);
////@end ImageViewer member initialisation
}


/*
 * Control creation for ImageViewer
 */

void ImageViewer::CreateControls()
{    
    ImageViewer* itemFrame1 = this;

    wxBoxSizer *sizer = new wxBoxSizer(wxVERTICAL);

    SetSizer(sizer);

    glPanel = new BasicGLPanel(this, 0);
    sizer->Add(glPanel, 1, wxEXPAND);
    SetBackgroundColour(wxColor(0, 0, 0));
    Show(false);

    timer.SetOwner(this, IMAGE_VIEWER_TIMER_ID);
}


/*
 * Should we show tooltips?
 */

bool ImageViewer::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap ImageViewer::GetBitmapResource( const wxString& name )
{
    wxUnusedVar(name);
    return wxNullBitmap;
}

/*
 * Get icon resources
 */

wxIcon ImageViewer::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin ImageViewer icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end ImageViewer icon retrieval
}

void ImageViewer::ClearKeys()
{
    int i, n = keys.size();

    for (i = 0; i < n; i++)
    {
        keys[i] = 0;
    }
}

void ImageViewer::OnIdle(wxIdleEvent &event)
{
	if (!IsShown())
		return;

    //cout << "ImageViewer::OnIdle" << endl;
    float dx = 0, dy = 0;

    if (keys['E'])        {glPanel->ZoomIn();       }
    if (keys['Q'])        {glPanel->ZoomOut();      }
    if (keys['W'] || keys[WXK_UP   ]) { dy += 10.0; }
    if (keys['S'] || keys[WXK_DOWN ]) { dy -= 10.0; }
    if (keys['A'] || keys[WXK_LEFT ]) { dx += 10.0; }
    if (keys['D'] || keys[WXK_RIGHT]) { dx -= 10.0; }

    if ((dx!=0) || (dy!=0))
        glPanel->MoveRel(dx, dy);

    glPanel->Render(GL_PANEL_RENDER_IMAGE);

    if (displayNumber > -1)
    {
        //cout << "displayNumber " << displayNumber << endl;
        glPanel->DisplayImage(displayNumber);
        displayNumber = -1;
    }
    event.RequestMore();
}


// Called by ThumbnailCanvas whenever an image is requested
// to be displayed.
// 
void ImageViewer::DisplayImage(int imageNumber)
{
    if (imageNumber < 0)
        return;

    if (imageNumber > fileNameList->MaxFileNumber())
        return;

    currentImage = imageNumber;

    if (glPanel)
    {
        Show(true);
        ShowFullScreen(true);
        displayNumber = imageNumber;
        SetFocus();
        Refresh();
        timer.Start(10);
    }

}

void ImageViewer::OnKeyDown(wxKeyEvent &event)
{
	lastKeyCode = event.GetKeyCode();
	//cout << "Key: " << event.GetKeyCode() << endl;
    switch (event.GetKeyCode())
    {
    case WXK_ESCAPE:
	case WXK_RETURN:
		cout << "Escape and clear" << endl;
        glPanel->Clear();
        currentImage = -1;
        ClearKeys();
        Show(false);
        ShowFullScreen(false);
        break;

    default:
        if (event.GetKeyCode() < keys.size())
            keys[event.GetKeyCode()] = 1;
        break;
    }
}


void ImageViewer::OnKeyUp(wxKeyEvent &event)
{
    //cout << "Frame Key Up" << event.GetKeyCode() << endl;
    switch (event.GetKeyCode())
    {
    case WXK_ESCAPE:
        //cout << "Escape" << endl;
        ClearKeys();
        //Show(false);
        //ShowFullScreen(false);
        break;

    case WXK_HOME:
        HomeImage();
        break;

    case WXK_END:
        EndImage();
        break;

    case 'R':
    case WXK_PAGEUP:
        PrevImage();
        break;

    case 'F':
    case WXK_PAGEDOWN:
        NextImage();
        break;

    default:
        if (event.GetKeyCode() < keys.size())
            keys[event.GetKeyCode()] = 0;
        break;
    }
}

void ImageViewer::OnClose(wxCloseEvent &event)
{
    wxGetApp().ExitMainLoop();
    /*
    cout << "ImageViewer::OnClose()" << endl;

    if (closeEnabled)
    {
        cout << "  closing me" << endl;
        Destroy();
    }
    else
    {
        cout << "  closing parent" << endl;
        GetParent()->Close();
    }
    */
    //event.veto();
    //event.Skip();
}

void ImageViewer::OnMouseWheel(wxMouseEvent &event)
{
    //cout << "Frame Wheel" << endl;
    int newImage = currentImage;

    if (event.GetWheelRotation() < 0)
    {
        PrevImage();
    }

    if (event.GetWheelRotation() > 0)
    {
        NextImage();
    }

    event.Skip();
}

void ImageViewer::HomeImage()
{
    //cout << "HomeImage" << endl;
    int newImage = 0;
    
    if (newImage > fileNameList->MaxFileNumber())
        newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}

void ImageViewer::EndImage()
{
    //cout << "HomeImage" << endl;
    int newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}

void ImageViewer::NextImage()
{
    int newImage = currentImage;
    newImage++;
    if (newImage > fileNameList->MaxFileNumber())
        newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}


void ImageViewer::PrevImage()
{
    int newImage = currentImage;

    newImage--;
    if (newImage < 0)
        newImage = 0;

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}

void ImageViewer::OnTimer(wxTimerEvent &event)
{
    if (!IsShown())
        return;

    //cout << "ImageViewer::OnIdle" << endl;
    float dx = 0, dy = 0;

    if (keys['E'])                      { glPanel->ZoomIn(); }
    if (keys['Q'])                      { glPanel->ZoomOut(); }
    if (keys['W'] || keys[WXK_UP]   )   { dy += 10.0; }
    if (keys['S'] || keys[WXK_DOWN] )   { dy -= 10.0; }
    if (keys['A'] || keys[WXK_LEFT] )   { dx += 10.0; }
    if (keys['D'] || keys[WXK_RIGHT])   { dx -= 10.0; }

    if ((dx != 0) || (dy != 0))
        glPanel->MoveRel(dx, dy);

    if (displayNumber > -1)
    {
        //cout << "displayNumber " << displayNumber << endl;
        glPanel->DisplayImage(displayNumber);
        displayNumber = -1;
    }

    if (currentImage >= 0)
        glPanel->Render(GL_PANEL_RENDER_IMAGE);
    else
        glPanel->Render(GL_PANEL_BLANK_SCREEN);
}
