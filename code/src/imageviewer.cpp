/////////////////////////////////////////////////////////////////////////////
// Name:        imageviewer.cpp
// Purpose:     
// Author:      Johnathan Lesbian Seagull
// Modified by: 
// Created:     05/01/2018 22:27:05
// RCS-ID:      
// Copyright:   
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 05/01/2018 22:27:05

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include <wx/app.h>
#include "image_browserapp.h"
#include "imageviewer.h"
#include "file_name_list.h"
#include "status_bar.h"
#include "thumbnail_canvas.h"
#include <iostream>

wxDECLARE_APP(Image_BrowserApp);

using namespace std;

////@begin XPM images

////@end XPM images


/*
 * ImageViewer type definition
 */

IMPLEMENT_CLASS( ImageViewer, wxFrame )
BEGIN_EVENT_TABLE( ImageViewer, wxFrame )
    EVT_KEY_DOWN(ImageViewer::OnKeyDown)
    EVT_KEY_UP(  ImageViewer::OnKeyUp)
    //EVT_IDLE(ImageViewer::OnIdle)
    EVT_TIMER(IMAGE_VIEWER_TIMER_ID, ImageViewer::OnTimer)
    EVT_MOUSEWHEEL(ImageViewer::OnMouseWheel)
    EVT_MOUSE_EVENTS(ImageViewer::OnMouse)
    EVT_LEFT_DCLICK(ImageViewer::OnMouseLDClick)
    EVT_CLOSE(ImageViewer::OnClose)
END_EVENT_TABLE()


/*
 * ImageViewer constructors
 */

ImageViewer::ImageViewer()
    : glPanel(0),
    fileNameList(0),
    currentImage(0),
    displayNumber(-1),
    disappearState(DISAPPEAR_STATE_NONE)
{
    Init();
}

ImageViewer::ImageViewer(ImageBrowser* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style)
: glPanel(),
  fileNameList(0),
  currentImage(0),
  displayNumber(-1),
  imageBrowser(parent),
  thumbnailCanvas(0),
  disappearState(DISAPPEAR_STATE_NONE)
{
    fileNameList = imageBrowser->GetFileNameList();
    Init();
    //cout << "ImageViewer::ImageViewer(" << parent << ") " << this << endl;

    wxSize sz(wxSystemSettings::GetMetric(wxSYS_SCREEN_X)+4, wxSystemSettings::GetMetric(wxSYS_SCREEN_Y)+4);
    //wxSize sz(400,400);
    //Create(parent, id, caption, wxPoint(-8, -8), sz, style);
    Create(parent, id, caption, wxPoint(-2, -2), sz, style);
    //Create(parent, id, caption, wxPoint(0,0), sz, style);

    //wxTextCtrl* dropTarget = new wxTextCtrl(this, wxID_ANY, _("Drop files onto me!"), wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE | wxTE_READONLY);
    //dropTarget->DragAcceptFiles(true);

    //wxSize sz(400,400);
    //Create(parent, id, caption, wxPoint(0, 0), sz, style);
}


/*
 * ImageViewer creator
 */


static int32_t emptyMask[] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                               0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};

bool ImageViewer::Create(ImageBrowser* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin ImageViewer creation
    //cout << "ImageViewer::Create(" << parent << ")" << endl;
    wxFrame::Create( parent, id, caption, pos, size, style );
    //cout << "ImageViewer::Create() Done Create Frame" << endl;

    CreateControls();
    Layout();
    wxBitmap bitmap((char*)emptyMask, 32, 32);
    wxBitmap   mask((char*)emptyMask, 32, 32);

    bitmap.SetMask(new wxMask(mask));
    wxImage hiddenImage = bitmap.ConvertToImage();
    hiddenImage.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_X, 16);
    hiddenImage.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_Y, 16);
    wxCursor hiddenCursor = wxCursor(hiddenImage);

    SetCursor(hiddenCursor);
    //Centre();
////@end ImageViewer creation
    return true;
}


/*
 * ImageViewer destructor
 */

ImageViewer::~ImageViewer()
{
////@begin ImageViewer destruction
////@end ImageViewer destruction
}


/*
 * Member initialisation
 */

void ImageViewer::Init()
{
    keys.resize(512, 0);
    ConfigParser *configParser = imageBrowser->GetConfigParser();

    videoFileExtensions = configParser->GetString("videoExtensions");
    videoPlayerPath     = configParser->GetString("videoPlayer");
}


/*
 * Control creation for ImageViewer
 */

void ImageViewer::CreateControls()
{    
    ImageViewer* itemFrame1 = this;
    
    wxBoxSizer *sizer = new wxBoxSizer(wxHORIZONTAL);

    SetSizer(sizer);

    glPanel = new BasicGLPanel(this, 0);
    //textCtrl = new wxTextCtrl(this, -1, wxT("Text Info"), wxDefaultPosition, wxSize(400, 1000), wxTE_MULTILINE|wxTE_READONLY);
    textCtrl = 0;

    sizer->Add(glPanel,  1, wxEXPAND);
    //sizer->Add(textCtrl, .1, wxEXPAND);
    SetBackgroundColour(wxColor(0, 0, 0));
    Show(false);

    timer.SetOwner(this, IMAGE_VIEWER_TIMER_ID);

    //wxAcceleratorEntry entries[1];
    //entries[0].Set(wxACCEL_CTRL, (int) 'D', ID_DELETE_DIRECTORY);
    //wxAcceleratorTable accel(1, entries);
    //this->SetAcceleratorTable(accel);
}


/*
 * Should we show tooltips?
 */

bool ImageViewer::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap ImageViewer::GetBitmapResource( const wxString& name )
{
    wxUnusedVar(name);
    return wxNullBitmap;
}

/*
 * Get icon resources
 */

wxIcon ImageViewer::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin ImageViewer icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end ImageViewer icon retrieval
}

void ImageViewer::ClearKeys()
{
    int i, n = keys.size();

    for (i = 0; i < n; i++)
    {
        keys[i] = 0;
    }
}

void ImageViewer::OnIdle(wxIdleEvent &event)
{
	if (!IsShown())
		return;

    //cout << "ImageViewer::OnIdle" << endl;
    float dx = 0, dy = 0;

    if (keys['E'])        {glPanel->ZoomIn();       }
    if (keys['Q'])        {glPanel->ZoomOut();      }
    if (keys['W'] || keys[WXK_UP   ]) { dy += 10.0; }
    if (keys['S'] || keys[WXK_DOWN ]) { dy -= 10.0; }
    if (keys['A'] || keys[WXK_LEFT ]) { dx += 10.0; }
    if (keys['D'] || keys[WXK_RIGHT]) { dx -= 10.0; }

    if ((dx!=0) || (dy!=0))
        glPanel->MoveRel(dx, dy);

    glPanel->Render(GL_PANEL_RENDER_IMAGE);

    if (displayNumber > -1)
    {
        //cout << "displayNumber " << displayNumber << endl;
        glPanel->DisplayImage(displayNumber);
        displayNumber = -1;
    }
    event.RequestMore();
}

void ImageViewer::ClearCache()
{
    glPanel->ClearCache();
}


void ImageViewer::DisplayImage(wxFileName fileName)
{
    /*
    wxString ext        = fileName.GetExt();
    ext.MakeLower();

    cout << "videoFileExtensions = " << videoFileExtensions << endl;

    if (videoFileExtensions.Contains(ext))
    {
        cout << "It's a video!" << endl;
        wxString command = videoPlayerPath + wxT(" \"") + fileName.GetFullPath() + wxT("\"");
        cout << command << endl;
        wxExecute(command.c_str(), wxEXEC_ASYNC, NULL);

        return;
    }


    //TEXT_MSG("ImageViewer::DisplayImage(%d)\n", imageNumber);

    if (imageNumber < 0)
        return;

    if (imageNumber > fileNameList->MaxFileNumber())
        return;

    currentImage = imageNumber;

    if (glPanel)
    {
        //TEXT_MSG("  Display\n");
        Show(true);
        ////ShowFullScreen(true);
        displayNumber = imageNumber;
        SetFocus();
        Refresh();
        timer.Start(10);
        disappearState = DISAPPEAR_STATE_NONE;
    }
    */
}

// Called by ThumbnailCanvas whenever an image is requested
// to be displayed.
// 
void ImageViewer::DisplayImage(int imageNumber)
{
    thumbnailCanvas->PauseLoadingThumbnails();
    int sortedImageNumber = thumbnailCanvas->GetSortedImageNumber(imageNumber);
    wxFileName fileName = (*fileNameList)[sortedImageNumber];
    wxString ext        = fileName.GetExt();
    ext.MakeLower();

    if (videoFileExtensions.Contains(ext))
    {
        wxString command = videoPlayerPath + wxT(" \"") + fileName.GetFullPath() + wxT("\"");
        cout << command << endl;
        wxExecute(command.c_str(), wxEXEC_ASYNC, NULL);

        return;
    }


    //TEXT_MSG("ImageViewer::DisplayImage(%d)\n", imageNumber);

    if (sortedImageNumber < 0)
        return;

    if (sortedImageNumber > fileNameList->MaxFileNumber())
        return;

    currentImage = imageNumber;

    if (glPanel)
    {
        //long styleflag = GetWindowStyle();
        //SetWindowStyle(styleflag | wxSTAY_ON_TOP);

        //TEXT_MSG("  Display\n");
        Show(true);
        ////ShowFullScreen(true);
        displayNumber = sortedImageNumber;
        SetFocus();
        Refresh();
        timer.Start(10);
        disappearState = DISAPPEAR_STATE_NONE;
    }
}


void ImageViewer::Disappear()
{
    thumbnailCanvas->ContinueLoadingThumbnails();
    glPanel->Clear();
    ClearKeys();

    thumbnailCanvas->SetCursor(currentImage);
    currentImage = -1;
    Show(false);
    thumbnailCanvas->SetFocus();
    disappearState = DISAPPEAR_STATE_NONE;
    thumbnailCanvas->SetFocus();
    imageBrowser->Show();
}

wxLongLong keyTime = 0;

void ImageViewer::OnKeyDown(wxKeyEvent &event)
{
    wxLongLong kt = wxGetLocalTimeMillis();
    keyTime = kt;


	lastKeyCode = event.GetKeyCode();
    switch (event.GetKeyCode())
    {
    case WXK_DELETE:
        if (!NextImage())
        {
            if (!PrevImage())
            {
                Disappear();
            }
        }
        thumbnailCanvas->DeleteImage(currentImage);
        break;

    case WXK_ESCAPE:
	case WXK_RETURN:
        disappearState = DISAPPEAR_STATE_REQUESTED;
        break;

    default:
            if (event.GetKeyCode() < keys.size())
                keys[event.GetKeyCode()] = 1;
        break;
    }
}


void ImageViewer::OnKeyUp(wxKeyEvent &event)
{
    int  pageJump = 5;
    int  lineJump = 1;
    int imageJump = 1;

    if (thumbnailCanvas)
    {
        lineJump = thumbnailCanvas->GetNumColumns();
        pageJump = thumbnailCanvas->GetNumImagesPerPage();
    }
    if (event.ShiftDown())
    {
        imageJump = lineJump;
    }

    switch (event.GetKeyCode())
    {
    case WXK_ESCAPE:
        ClearKeys();
        break;

    case WXK_HOME:
        HomeImage();
        break;

    case WXK_END:
        EndImage();
        break;

    case 'R':
    case WXK_PAGEUP:
        PrevImage(imageJump);
        break;

    case 'F':
    case WXK_PAGEDOWN:
        NextImage(imageJump);
        break;

    case 'V':
        NextImage(pageJump);
        break;

    case '4':
        PrevImage(pageJump);
        break;

    default:
        if (event.GetKeyCode() < keys.size())
            keys[event.GetKeyCode()] = 0;
        break;
    }
}

void ImageViewer::OnClose(wxCloseEvent &event)
{
    wxGetApp().ExitMainLoop();
}

void ImageViewer::OnMouseWheel(wxMouseEvent &event)
{
    int newImage = currentImage;

    if (event.GetWheelRotation() > 0)
    {
        PrevImage();
    }

    if (event.GetWheelRotation() < 0)
    {
        NextImage();
    }

    event.Skip();
}


void ImageViewer::OnMouse(wxMouseEvent& event)
{
    if (event.LeftDClick())
    {
        disappearState = DISAPPEAR_STATE_REQUESTED;
    }
}

void ImageViewer::OnMouseLDClick(wxMouseEvent& event)
{
    Disappear();
}

void ImageViewer::HomeImage()
{
    unsigned int newImage = 0;
    
    if (newImage > fileNameList->MaxFileNumber())
        newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}

void ImageViewer::EndImage()
{
    unsigned int newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
    }
}

bool ImageViewer::NextImage(int jump)
{
    unsigned int newImage = currentImage;
    newImage += jump;

    if (newImage > fileNameList->MaxFileNumber())
        newImage = fileNameList->MaxFileNumber();

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
        return true;
    }
    else
    {
        return false;
    }
}


bool ImageViewer::PrevImage(int jump)
{
    int newImage = currentImage;

    newImage -= jump;
    if (newImage < 0)
        newImage = 0;

    if (currentImage != newImage)
    {
        DisplayImage(newImage);
        Refresh();
        return true;
    }
    else
    {
        return false;
    }
}

wxLongLong onTimer = 0;

void NoteTime(wxString s)
{
    static wxULongLong timePrev;
    wxULongLong timeNow;

    timeNow = wxGetLocalTimeMillis();

    cout << "TIME NOTE: " << s.c_str() << " " << timeNow - timePrev << endl;
    timePrev = timeNow;
}


void ImageViewer::ResetZoom()
{
    glPanel->currentImage = 0;
}

void ImageViewer::OnTimer(wxTimerEvent &event)
{
    if (!IsShown())
    {
        return;
    }

    float dx = 0, dy = 0;

    if (keys['E'])                      { glPanel->ZoomIn(); }
    if (keys['Q'])                      { glPanel->ZoomOut(); }
    if (keys['W'] || keys[WXK_UP]   )   { dy += 10.0; }
    if (keys['S'] || keys[WXK_DOWN] )   { dy -= 10.0; }
    if (keys['A'] || keys[WXK_LEFT] )   { dx += 10.0; }
    if (keys['D'] || keys[WXK_RIGHT])   { dx -= 10.0; }

    if ((dx != 0) || (dy != 0))
        glPanel->MoveRel(dx, dy);

    if (displayNumber > -1)
    {
        //cout << "displayNumber " << displayNumber << endl;
        glPanel->DisplayImage(displayNumber);
        displayNumber = -1;
    }
    //NoteTime(wxT("  display"));

    //cout << "disappearState = " << disappearState << endl;

    switch (disappearState)
    {
    case DISAPPEAR_STATE_NONE:
        if (currentImage >= 0)
        {
            glPanel->Render(GL_PANEL_RENDER_IMAGE);
        }
        break;

    case DISAPPEAR_STATE_REQUESTED:
        glPanel->Render(GL_PANEL_BLANK_SCREEN);
        disappearState = DISAPPEAR_STATE_CLOSING;
        break;

    case DISAPPEAR_STATE_CLOSING:
        Disappear();
        disappearState = DISAPPEAR_STATE_CLOSED;
        break;
    }
    //NoteTime(wxT("  render"));
}

